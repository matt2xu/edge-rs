<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `edge` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, edge">

    <title>edge - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'edge', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>edge</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-0' class='srclink' href='../src/edge/src/lib.rs.html#1-394' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>Edge is a Web framework that is simple to use, with the most common things
you need out of the box, and flexible, supporting both synchronous and asynchronous
request handling styles; see below for examples.</p>

<p>The crate exports the things that you often need from dependencies, such as headers (from <code>hyper</code>),
cookies (from <code>cookie</code>) and JSON serialization (from <code>serde_json</code>).</p>

<p>Please note that this is an early version, and the API is likely to evolve.</p>

<h2 id='overview' class='section-header'><a href='#overview'>Overview</a></h2>
<p>In Edge you must define an <em>application structure</em> that contains the state of your application.
You instantiate a container around this application, and associate GET/POST/... requests
with given URLs to methods of your application. The container handles the routing and
delegates calls to the appropriate methods.</p>

<p>Note that the state cannot be mutated, as is usual in Rust (and enforced by the underlying HTTP server
this crate uses, a.k.a. Hyper). Use appropriate concurrent data structures if you need
shared mutable variables: locks, mutexes, channels, etc.</p>

<h2 id='why-another-web-framework-in-rust' class='section-header'><a href='#why-another-web-framework-in-rust'>Why another Web framework in Rust?</a></h2>
<p>Because I wanted a simple Web framework with:</p>

<ol>
<li>everything I needed out of the box, like cookies and forms and templating, without having to dig up third-party crates,</li>
<li>the possibility to describe my application as a struct, so that callbacks could use a state (even if just for configuration).</li>
</ol>

<p>We focus on integration rather than modularity.
I hope you like this crate, if it misses something to fit your needs just open an issue or make a pull request!</p>

<p>And please keep in mind that the framework is in a (very) early stage :-)</p>

<h2 id='hello-world' class='section-header'><a href='#hello-world'>Hello World</a></h2>
<p>The most basic application: no state, a single page that prints Hello, world!</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>edge</span>;

<span class='kw'>use</span> <span class='ident'>edge</span>::{<span class='ident'>Edge</span>, <span class='ident'>Request</span>, <span class='ident'>Response</span>};

<span class='kw'>struct</span> <span class='ident'>MyApp</span>;
<span class='kw'>impl</span> <span class='ident'>MyApp</span> {
    <span class='kw'>fn</span> <span class='ident'>hello</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>_req</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Request</span>, <span class='kw-2'>mut</span> <span class='ident'>res</span>: <span class='ident'>Response</span>) {
        <span class='ident'>res</span>.<span class='ident'>content_type</span>(<span class='string'>&quot;text/plain&quot;</span>);
        <span class='ident'>res</span>.<span class='ident'>send</span>(<span class='string'>&quot;Hello, world!&quot;</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cter</span> <span class='op'>=</span> <span class='ident'>Edge</span>::<span class='ident'>new</span>(<span class='ident'>MyApp</span>);
    <span class='ident'>cter</span>.<span class='ident'>get</span>(<span class='string'>&quot;/&quot;</span>, <span class='ident'>MyApp</span>::<span class='ident'>hello</span>);
    <span class='ident'>cter</span>.<span class='ident'>start</span>(<span class='string'>&quot;0.0.0.0:3000&quot;</span>).<span class='ident'>unwrap</span>();
}</pre>

<h2 id='asynchronous-handling' class='section-header'><a href='#asynchronous-handling'>Asynchronous handling</a></h2>
<p>Under the hood, Edge uses the asynchronous version of Hyper. This means that to get the maximum
performance, you should avoid waiting in a handler, so that other requests
can be served as soon as possible. In that example, the handler waits in a separate thread before sending
the response.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>edge</span>;

<span class='kw'>use</span> <span class='ident'>edge</span>::{<span class='ident'>Edge</span>, <span class='ident'>Request</span>, <span class='ident'>Response</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>struct</span> <span class='ident'>MyApp</span>;
<span class='kw'>impl</span> <span class='ident'>MyApp</span> {
    <span class='kw'>fn</span> <span class='ident'>hello</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>_req</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Request</span>, <span class='kw-2'>mut</span> <span class='ident'>res</span>: <span class='ident'>Response</span>) {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;waiting 1 second&quot;</span>);
            <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_secs</span>(<span class='number'>1</span>));

            <span class='ident'>res</span>.<span class='ident'>content_type</span>(<span class='string'>&quot;text/plain&quot;</span>);
            <span class='ident'>res</span>.<span class='ident'>send</span>(<span class='string'>&quot;Hello, world!&quot;</span>)
        });

        <span class='comment'>// the handler returns immediately without waiting for the thread</span>
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cter</span> <span class='op'>=</span> <span class='ident'>Edge</span>::<span class='ident'>new</span>(<span class='ident'>MyApp</span>);
    <span class='ident'>cter</span>.<span class='ident'>get</span>(<span class='string'>&quot;/&quot;</span>, <span class='ident'>MyApp</span>::<span class='ident'>hello</span>);
    <span class='ident'>cter</span>.<span class='ident'>start</span>(<span class='string'>&quot;0.0.0.0:3000&quot;</span>).<span class='ident'>unwrap</span>();
}</pre>

<h2 id='templating' class='section-header'><a href='#templating'>Templating</a></h2>
<p>Here our application has a version, still a single handler except this time
it accepts any page name, and renders a Handlebars template.  We&#39;re also
setting a custom Server header.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>edge</span>;

<span class='kw'>use</span> <span class='ident'>edge</span>::{<span class='ident'>Edge</span>, <span class='ident'>Request</span>, <span class='ident'>Response</span>, <span class='ident'>Status</span>};
<span class='kw'>use</span> <span class='ident'>edge</span>::<span class='ident'>header</span>::<span class='ident'>Server</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>BTreeMap</span>;

<span class='kw'>struct</span> <span class='ident'>MyApp</span> {
    <span class='ident'>version</span>: <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span>
}

<span class='kw'>impl</span> <span class='ident'>MyApp</span> {
    <span class='kw'>fn</span> <span class='ident'>page_handler</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>req</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Request</span>, <span class='kw-2'>mut</span> <span class='ident'>res</span>: <span class='ident'>Response</span>) {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='ident'>BTreeMap</span>::<span class='ident'>new</span>();
        <span class='ident'>data</span>.<span class='ident'>insert</span>(<span class='string'>&quot;title&quot;</span>, <span class='ident'>req</span>.<span class='ident'>param</span>(<span class='string'>&quot;page&quot;</span>).<span class='ident'>unwrap</span>());
        <span class='ident'>data</span>.<span class='ident'>insert</span>(<span class='string'>&quot;version&quot;</span>, <span class='self'>self</span>.<span class='ident'>version</span>);

        <span class='ident'>res</span>.<span class='ident'>content_type</span>(<span class='string'>&quot;text/html&quot;</span>).<span class='ident'>header</span>(<span class='ident'>Server</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Edge version {}&quot;</span>, <span class='self'>self</span>.<span class='ident'>version</span>)));
        <span class='ident'>res</span>.<span class='ident'>render</span>(<span class='string'>&quot;views/page.hbs&quot;</span>, <span class='ident'>data</span>)
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>app</span> <span class='op'>=</span> <span class='ident'>MyApp</span> { <span class='ident'>version</span>: <span class='string'>&quot;0.1&quot;</span> };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cter</span> <span class='op'>=</span> <span class='ident'>Edge</span>::<span class='ident'>new</span>(<span class='ident'>app</span>);
    <span class='ident'>cter</span>.<span class='ident'>get</span>(<span class='string'>&quot;/:page&quot;</span>, <span class='ident'>MyApp</span>::<span class='ident'>page_handler</span>);
    <span class='ident'>cter</span>.<span class='ident'>start</span>(<span class='string'>&quot;0.0.0.0:3000&quot;</span>).<span class='ident'>unwrap</span>();
}</pre>

<h2 id='using-a-shared-mutable-counter' class='section-header'><a href='#using-a-shared-mutable-counter'>Using a shared mutable counter</a></h2>
<p>In this example, we use an atomic integer to track a counter. This shows a very basic
kind of shared state for a handler. In practice, it&#39;s best to avoid using blocking
mechanisms (locks, mutexes) in a handler directly. Prefer non-blocking calls,
like channels&#39; try_recv, or move blocking code in a separate thread,
see the example for asynchronous handling above.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>edge</span>;

<span class='kw'>use</span> <span class='ident'>edge</span>::{<span class='ident'>Edge</span>, <span class='ident'>Request</span>, <span class='ident'>Response</span>, <span class='ident'>Status</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>atomic</span>::{<span class='ident'>AtomicUsize</span>, <span class='ident'>Ordering</span>};

<span class='kw'>struct</span> <span class='ident'>MyApp</span> {
    <span class='ident'>counter</span>: <span class='ident'>AtomicUsize</span>
}

<span class='kw'>impl</span> <span class='ident'>MyApp</span> {
    <span class='kw'>fn</span> <span class='ident'>home</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>_req</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Request</span>, <span class='kw-2'>mut</span> <span class='ident'>res</span>: <span class='ident'>Response</span>) {
        <span class='kw'>let</span> <span class='ident'>visits</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>counter</span>.<span class='ident'>load</span>(<span class='ident'>Ordering</span>::<span class='ident'>Relaxed</span>);
        <span class='self'>self</span>.<span class='ident'>counter</span>.<span class='ident'>store</span>(<span class='ident'>visits</span> <span class='op'>+</span> <span class='number'>1</span>, <span class='ident'>Ordering</span>::<span class='ident'>Relaxed</span>);

        <span class='ident'>res</span>.<span class='ident'>status</span>(<span class='ident'>Status</span>::<span class='prelude-val'>Ok</span>).<span class='ident'>content_type</span>(<span class='string'>&quot;text/plain&quot;</span>);
        <span class='ident'>res</span>.<span class='ident'>send</span>(<span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world! {} visits&quot;</span>, <span class='ident'>visits</span>))
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>app</span> <span class='op'>=</span> <span class='ident'>MyApp</span> { <span class='ident'>counter</span>: <span class='ident'>AtomicUsize</span>::<span class='ident'>new</span>(<span class='number'>0</span>) };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cter</span> <span class='op'>=</span> <span class='ident'>Edge</span>::<span class='ident'>new</span>(<span class='ident'>app</span>);
    <span class='ident'>cter</span>.<span class='ident'>get</span>(<span class='string'>&quot;/&quot;</span>, <span class='ident'>MyApp</span>::<span class='ident'>home</span>);
    <span class='ident'>cter</span>.<span class='ident'>start</span>(<span class='string'>&quot;0.0.0.0:3000&quot;</span>).<span class='ident'>unwrap</span>();
}</pre>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='mod' href='header/index.html'
                               title='edge::header'>header</a></td>
                        <td class='docblock short'>
                             <p>Headers container, and common header fields.</p>
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='mod' href='value/index.html'
                               title='edge::value'>value</a></td>
                        <td class='docblock short'>
                             <p>JSON Value</p>
                        </td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Cookie.html'
                               title='edge::Cookie'>Cookie</a></td>
                        <td class='docblock short'>
                             
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Edge.html'
                               title='edge::Edge'>Edge</a></td>
                        <td class='docblock short'>
                             <p>Structure for an Edge application.</p>
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.EdgeHandler.html'
                               title='edge::EdgeHandler'>EdgeHandler</a></td>
                        <td class='docblock short'>
                             
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Request.html'
                               title='edge::Request'>Request</a></td>
                        <td class='docblock short'>
                             <p>A request, with a path, query, and fragment (accessor methods not yet implemented for the last two).</p>
                        </td>
                    </tr>
                
                    <tr class=' module-item'>
                        <td><a class='struct' href='struct.Response.html'
                               title='edge::Response'>Response</a></td>
                        <td class='docblock short'>
                             <p>This represents the response that will be sent back to the application.</p>
                        </td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='enum' href='enum.Status.html'
                               title='edge::Status'>Status</a></td>
                        <td class='docblock short'>
                             <p>An HTTP status code (<code>status-code</code> in RFC 7230 et al.).</p>
                        </td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr class=' module-item'>
                        <td><a class='type' href='type.Callback.html'
                               title='edge::Callback'>Callback</a></td>
                        <td class='docblock short'>
                             <p>Signature for a callback method</p>
                        </td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "edge";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>